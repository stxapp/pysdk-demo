{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to SportsX SDK Documentation \u00b6 Overview \u00b6 The STX SDK is a wrapper around the Sportsx Graphql APIs and Phoenix channels. The SDK provides object-oriented APIs to connect with the available Sportsx APIs and socket channels. Compatibility \u00b6 This library is compatible with the following versions of Python: 3.7 3.8 3.9 Installation \u00b6 Install the latest release via pip: pip install stx-pysdk The SDK is built for python 3 only. If your system has both python2 and python3 manager installed then by default \"pip\" refers to python2 manager, so in order to install for python3 \"pip3\" would be used pip3 install stx-pysdk","title":"Home"},{"location":"#welcome-to-sportsx-sdk-documentation","text":"","title":"Welcome to SportsX SDK Documentation"},{"location":"#overview","text":"The STX SDK is a wrapper around the Sportsx Graphql APIs and Phoenix channels. The SDK provides object-oriented APIs to connect with the available Sportsx APIs and socket channels.","title":"Overview"},{"location":"#compatibility","text":"This library is compatible with the following versions of Python: 3.7 3.8 3.9","title":"Compatibility"},{"location":"#installation","text":"Install the latest release via pip: pip install stx-pysdk The SDK is built for python 3 only. If your system has both python2 and python3 manager installed then by default \"pip\" refers to python2 manager, so in order to install for python3 \"pip3\" would be used pip3 install stx-pysdk","title":"Installation"},{"location":"guide/","text":"Developer Guide \u00b6 Synchronous Client - HTTP requests \u00b6 Initialization \u00b6 To initialize the client: examples/stxclient/init.py from stxsdk import StxClient client = StxClient () Authentication \u00b6 Before performing any operation you must authenticate first, if the provided credentials are correct the login API will store the tokens automatically to be used for authenticated APIs otherwise it will return authentication failure response. examples/stxclient/login.py from stxsdk import StxClient client = StxClient () email = \"<email address>\" password = \"<password>\" result = client . login ( params = { \"email\" : email , \"password\" : password }, ) The user token and refresh token validity is automatically handled by the client internally, and you don\"t need to worry about handling the authentication and authorization. For understanding the token expiry is 1 hour and refresh token expiry is 24 hours. 2 Factor Authentication \u00b6 If the 2FA is enabled, you must execute the confirm2fa to authenticate the user before calling any other operation, otherwise you will get the authentication failure response. examples/stxclient/confirm2FA.py from stxsdk import StxClient client = StxClient () email = \"<email address>\" password = \"<password>\" client . login ( params = { \"email\" : email , \"password\" : password }, ) # After login, if 2FA is enabled, you will receive the code on the requested email address client . confirm2Fa ( params = { \"code\" : \"865347\" , } ) User Profile \u00b6 To get the user profile details examples/stxclient/user_profile.py from stxsdk import StxClient , Selection client = StxClient () email = \"<email address>\" password = \"<password>\" client . login ( params = { \"email\" : email , \"password\" : password }, ) selections = Selection ( \"accountId\" , \"city\" , \"country\" , \"firstName\" , \"lastName\" , \"username\" , \"id\" , ) result = client . userProfile ( selections = selections ) Response { \"data\" : { \"userProfile\" : { \"accountId\" : \"6a7fb2e7-1413-4b8b-b126-6a8eaab128a8\" , \"city\" : \"New York\" , \"country\" : No ne , \"firstName\" : \"Muhamad\" , \"id\" : \"d9988022-037e-4441-8132-69d1bc58343f\" , \"lastName\" : \"Ali\" , \"username\" : \"Ali.Muhamad.86702\" }}, \"errors\" : No ne , \"message\" : \"Request Processed Successfully\" , \"success\" : True , } Utilities \u00b6 Here you can see a Selection object is being created to pass as an argument selections to the userProfile function. If you doesn't pass the selections, you will get all the fields in return by default. Selections parameter is used to pass the fields that you want in return from the APIs. Now the question is how would you know which fields are available in the response of the API. We have a utility method get_return_fields that takes the name of the operation as a string and returns all the available response values with their names and types. To get the return fields from stxsdk import StxClient client = StxClient () result = client . get_return_fields ( \"userProfile\" ) Response { \"accountId\" : \"rID\" , \"address1\" : \"String\" , \"address2\" : \"String\" , \"city\" : \"String\" , \"country\" : \"String\" , \"dateOfBirth\" : \"String\" , \"firstName\" : \"String!\" , \"id\" : \"rID!\" , \"industry\" : \"String\" , \"jobTitle\" : \"String\" , \"lastName\" : \"String!\" , \"optInMarketing\" : \"Boolean\" , \"phoneNumber\" : \"String\" , \"ssn\" : \"String\" , \"state\" : \"String\" , \"twoFactorAuth\" : \"Boolean\" , \"twoFactorAuthPerDevice\" : \"Boolean\" , \"username\" : \"String!\" , \"zipCode\" : \"String\" } Now what about the response with nested fields, checkout the following example: To get the return values with nested fields from stxsdk import StxClient client = StxClient () result = client . get_return_fields ( \"marketInfos\" ) Response { \"archived\" : \"Boolean\" , \"closedAt\" : \"String\" , \"description\" : \"String\" , \"detailedEventBrief\" : \"String\" , \"homeCategory\" : \"String\" , \"eventId\" : \"rID\" , \"eventStart\" : \"String\" , \"eventStatus\" : \"String\" , \"title\" : \"String\" , \"eventType\" : \"String\" , \"eventBrief\" : \"String\" , \"lastProbabilityAt\" : \"DateTime\" , \"lastTradedPrice\" : \"Int\" , \"manualProbability\" : \"Boolean\" , \"marketId\" : \"rID\" , \"maxPrice\" : \"Int\" , \"position\" : \"String\" , \"price\" : \"Float\" , \"priceChange24h\" : \"Int\" , \"probability\" : \"Float\" , \"question\" : \"String\" , \"result\" : \"String\" , \"shortTitle\" : \"String\" , \"rulesSpecifier\" : \"String\" , \"specifier\" : \"String\" , \"status\" : \"String\" , \"timestamp\" : \"String\" , \"timestampInt\" : \"Int\" , \"volume24h\" : \"Int\" , \"symbol\" : \"String\" , \"tradingFilters\" : { \"category\" : \"String\" , \"manual\" : \"Boolean\" , \"section\" : \"String\" , \"subcategory\" : \"String\" }, \"recentTrades\" : { \"liquidityTaker\" : \"String\" , \"price\" : \"Int\" , \"quantity\" : \"Int\" , \"timestamp\" : \"String\" , \"timestampInt\" : \"Int\" }, \"offers\" : { \"price\" : \"Int\" , \"quantity\" : \"Int\" }, \"orderPriceRules\" : { \"from\" : \"Int\" , \"inc\" : \"Int\" , \"to\" : \"Int\" }, \"filters\" : { \"category\" : \"String\" , \"manual\" : \"Boolean\" , \"section\" : \"String\" , \"subcategory\" : \"String\" }, \"bids\" : { \"price\" : \"Int\" , \"quantity\" : \"Int\" } } You will get two types of responses in return from any operation Success Response { # API respo nse , i t could be lis t or dic t io nar y \"data\" : {}, # i t would always be No ne i n case o f success \"errors\" : No ne , # Success Message \"message\" : \"Request Processed Successfully\" , # A boolea n f ield , would always be True i n case o f success respo nse \"success\" : True , } Failure Response { # i t would be No ne i n case o f fa ilure \"data\" : No ne , # i t would a lis t o f errors \"errors\" : [], # Ge neral fa ilure message \"message\" : \"Failed to process the request\" , # A boolea n f ield , would always be False i n case o f success respo nse \"success\" : False , } You can also use the following function to get the list of available operations To get the list of avaiable operations from stxsdk import StxClient client = StxClient () result = client . get_operations () Market Infos \u00b6 In the following example code you can see the usage of Selection object to set nested values examples/stxclient/market_info.py from stxsdk import StxClient , Selection client = StxClient () email = \"<email address>\" password = \"<password>\" client . login ( params = { \"email\" : email , \"password\" : password }, ) # you can create separate selection object and set them as keyword argument # or can create them inline # here created selection object for the field orderPriceRules and # pass it as keyword argument order_price_rules = Selection ( \"from\" , \"inc\" , \"to\" ) selections = Selection ( \"closedAt\" , \"description\" , \"eventId\" , \"marketId\" , \"title\" , \"status\" , orderPriceRules = order_price_rules , # inline selection object bids = Selection ( \"price\" , \"quantity\" ), ) result = client . marketInfos ( selections = selections ) Confirm Order \u00b6 examples/stxclient/confirm_order.py from stxsdk import StxClient , Selection client = StxClient () email = \"<email address>\" password = \"<password>\" client . login ( params = { \"email\" : email , \"password\" : password }, ) params = { \"userOrder\" : { \"marketId\" : \"ec202f18-cc6c-4fa2-90cb-f0c9162afced\" , # orderType: LIMIT | MARKET \"orderType\" : \"LIMIT\" , # action: BUY | SELL \"action\" : \"BUY\" , \"price\" : 1 , \"quantity\" : 5 , } } selections = Selection ( \"errors\" , order = Selection ( \"id\" , \"totalValue\" , \"status\" , \"action\" , \"clientOrderId\" ) ) result = client . confirmOrder ( params = params , selections = selections ) Cancel Order \u00b6 examples/stxclient/cancel_order.py from stxsdk import StxClient , Selection client = StxClient () email = \"<email address>\" password = \"<password>\" client . login ( params = { \"email\" : email , \"password\" : password }, ) params = { \"orderId\" : \"85b670f1-19b7-4378-8b91-6b4d7cc4a46b\" } selections = Selection ( \"status\" ) result = client . cancelOrder ( params = params , selections = selections ) Trade History \u00b6 examples/stxclient/trade_history.py from stxsdk import StxClient , Selection client = StxClient () email = \"<email address>\" password = \"<password>\" client . login ( params = { \"email\" : email , \"password\" : password }, ) selections = Selection ( \"totalCount\" , orders = Selection ( \"id\" , \"orderType\" , \"price\" , \"quantity\" , \"clientOrderId\" , \"totalValue\" , \"marketId\" , \"status\" , ), ) result = client . myOrderHistory ( selections = selections ) Asynchronous Client - Websocket requests \u00b6 This service provides the functionality to connect with the Sportsx phoenix channel via websockets. Available Channels \u00b6 Channel Description portfolio_join It delivers updates to users' available balance market_info_join It gives information about active markets active_trades_join It delivers information to the subscriber on a trade executed against an order that is filled against an active market in the system active_orders_join It delivers information to the subscriber on order that are filled against an active market in the system active_settlements_join It delivers information to the subscriber on a settlement recorded against on an account for an active market in the system. active_positions_join It delivers information to the subscriber on a position an account holds in an active market Initialization \u00b6 To initialize the client: examples/stxchannelclient/init.py email = \"<email address>\" password = \"<password>\" channel_client = StxChannelClient () channel_client . login ( params = { \"email\" : email , \"password\" : password }) channel_client = StxChannelClient () Note First of all, needs to know that the User management is built on singleton approach, It means that no matter how many StxClient or StxChannelClient objects you create all of them will be sharing the same user object. It is required to have authentication before initiating the async client for building the connection with the channels. In the following example you can see I used asyncio library for async communication with channels asyncio is Python's builtin library to write concurrent code using the async/await syntax. You can learn more about asyncio on its official documentation What is Consumer? It's a function or service that would be triggered by the async client, means that the channels' message will automatically hand off to a message listener which passes to the consumer that has been registered. The client consumes the message when a session thread invokes the onMessage() method of the message listener object. Our ChannelClient accepts different consumers for each event. The available events are the following: Event Description on_open It triggers when connected with the server on_message It triggers when connection to the server is closed on_close It triggers when connection to the server is closed on_error It triggers when any error send by the server or exception occurs default all of the above events are optional to be set, if you want a generic method to be run as default you can pass as it with default kwarg Response Syntax \u00b6 Success Message { \"closed\" : False , \"message_received\" : True , \"message\" : \"Message received\" , # i t would a lis t co nta i n i n g message o f t he cha nnel \"data\" : [], } Below is the sample data of the portfolio channel Sample Message Response of the Channel [ \"3\" , No ne , \"portfolio:EY8Zk0HKYbaMsiG8id81MTE0V1D3\" , \"summary\" , { \"account_balance\" : 2000000 , \"account_id\" : \"6a7fb2e7-1413-4b8b-b126-6a8eaab128a8\" , \"available_balance\" : 2000000 , \"buy_order_liability\" : 0 , \"escrow\" : 0 , \"position_premium_liability\" : 0 , \"sell_order_liability\" : 0 , \"total_deposits\" : 2000000 , \"total_fees\" : 0 , \"total_settlement_pnl\" : 0 , \"total_withdrawals\" : 0 , \"user_id\" : \"ca84fb65-5df2-456b-80ec-903a068bbdd2\" } ] Portfolio Channel \u00b6 examples/stxchannelclient/portfolio.py import asyncio from examples.stxchannelclient.init import channel_client async def on_open ( response ): # message passed by the listener of the async client when connect with the server # you can perform any initial operation on this event print ( f \"Successfully connected with the server with message, { response } \" ) async def on_message ( response ): # message passed by the listener of the async client when server send the message # you can perform any post operation on this event print ( response [ \"data\" ]) async def default ( response ): # Here response would be the response passed by the listener of the async client if response [ \"closed\" ]: print ( response [ \"message\" ]) elif response [ \"data\" ] is None : print ( \"No data return from server.\" ) else : print ( response [ \"data\" ][ 4 ]) # StxChannelClient provides the channel function as an asynchronous tasks, in order to execute # them async in a continuous loop using the asyncio module's event loop, # asynio is Python's built-in package that provides a foundation and API for running and managing coroutines. # here you can see that am only passing functions for on_open and on_message events # with a default function to handle other events asyncio . run ( channel_client . portfolio_join ( on_open = on_open , on_message = on_message , default = default , ) ) Market Info Channel \u00b6 examples/stxchannelclient/market_info.py import asyncio from examples.stxchannelclient.init import channel_client async def on_open ( response ): # message passed by the listener of the async client when connect with the server # you can perform any initial operation on this event print ( f \"Successfully connected with the server with message, { response } \" ) async def on_message ( response ): # message passed by the listener of the async client when server send the message # you can perform any post operation on this event print ( response [ \"data\" ]) async def default ( response ): # Here response would be the response passed by the listener of the async client if response [ \"closed\" ]: print ( response [ \"message\" ]) elif response [ \"data\" ] is None : print ( \"No data return from server.\" ) else : print ( response [ \"data\" ][ 4 ]) # StxChannelClient provides the channel function as an asynchronous tasks, in order to execute # them async in a continuous loop using the asyncio module's event loop, # asynio is Python's built-in package that provides a foundation and API for running and managing coroutines. # here you can see that am only passing functions for on_open and on_message events # with a default function to handle other events asyncio . run ( channel_client . market_info_join ( on_open = on_open , on_message = on_message , default = default , ) ) Active Trades Channel \u00b6 examples/stxchannelclient/active_trade.py import asyncio from examples.stxchannelclient.init import channel_client async def on_open ( response ): # message passed by the listener of the async client when connect with the server # you can perform any initial operation on this event print ( f \"Successfully connected with the server with message, { response } \" ) async def on_message ( response ): # message passed by the listener of the async client when server send the message # you can perform any post operation on this event print ( response [ \"data\" ]) async def default ( response ): # Here response would be the response passed by the listener of the async client if response [ \"closed\" ]: print ( response [ \"message\" ]) elif response [ \"data\" ] is None : print ( \"No data return from server.\" ) else : print ( response [ \"data\" ][ 4 ]) # StxChannelClient provides the channel function as an asynchronous tasks, in order to execute # them async in a continuous loop using the asyncio module's event loop, # asynio is Python's built-in package that provides a foundation and API for running and managing coroutines. # here you can see that am only passing functions for on_open and on_message events # with a default function to handle other events asyncio . run ( channel_client . active_trades_join ( on_open = on_open , on_message = on_message , default = default , ) ) Active Orders Channel \u00b6 examples/stxchannelclient/active_order.py import asyncio from examples.stxchannelclient.init import channel_client async def on_open ( response ): # message passed by the listener of the async client when connect with the server # you can perform any initial operation on this event print ( f \"Successfully connected with the server with message, { response } \" ) async def on_message ( response ): # message passed by the listener of the async client when server send the message # you can perform any post operation on this event print ( response [ \"data\" ]) async def default ( response ): # Here response would be the response passed by the listener of the async client if response [ \"closed\" ]: print ( response [ \"message\" ]) elif response [ \"data\" ] is None : print ( \"No data return from server.\" ) else : print ( response [ \"data\" ][ 4 ]) # StxChannelClient provides the channel function as an asynchronous tasks, in order to execute # them async in a continuous loop using the asyncio module's event loop, # asynio is Python's built-in package that provides a foundation and API for running and managing coroutines. # here you can see that am only passing functions for on_open and on_message events # with a default function to handle other events asyncio . run ( channel_client . active_orders_join ( on_open = on_open , on_message = on_message , default = default , ) ) Active Settlement Channel \u00b6 examples/stxchannelclient/active_settlements.py import asyncio from examples.stxchannelclient.init import channel_client async def on_open ( response ): # message passed by the listener of the async client when connect with the server # you can perform any initial operation on this event print ( f \"Successfully connected with the server with message, { response } \" ) async def on_message ( response ): # message passed by the listener of the async client when server send the message # you can perform any post operation on this event print ( response [ \"data\" ]) async def default ( response ): # Here response would be the response passed by the listener of the async client if response [ \"closed\" ]: print ( response [ \"message\" ]) elif response [ \"data\" ] is None : print ( \"No data return from server.\" ) else : print ( response [ \"data\" ][ 4 ]) # StxChannelClient provides the channel function as an asynchronous tasks, in order to execute # them async in a continuous loop using the asyncio module's event loop, # asynio is Python's built-in package that provides a foundation and API for running and managing coroutines. # here you can see that am only passing functions for on_open and on_message events # with a default function to handle other events asyncio . run ( channel_client . active_settlements_join ( on_open = on_open , on_message = on_message , default = default , ) ) Active Positions Channel \u00b6 examples/stxchannelclient/active_positions.py import asyncio from examples.stxchannelclient.init import channel_client async def on_open ( response ): # message passed by the listener of the async client when connect with the server # you can perform any initial operation on this event print ( f \"Successfully connected with the server with message, { response } \" ) async def on_message ( response ): # message passed by the listener of the async client when server send the message # you can perform any post operation on this event print ( response [ \"data\" ]) async def default ( response ): # Here response would be the response passed by the listener of the async client if response [ \"closed\" ]: print ( response [ \"message\" ]) elif response [ \"data\" ] is None : print ( \"No data return from server.\" ) else : print ( response [ \"data\" ][ 4 ]) # StxChannelClient provides the channel function as an asynchronous tasks, in order to execute # them async in a continuous loop using the asyncio module's event loop, # asynio is Python's built-in package that provides a foundation and API for running and managing coroutines. # here you can see that am only passing functions for on_open and on_message events # with a default function to handle other events asyncio . run ( channel_client . active_positions_join ( on_open = on_open , on_message = on_message , default = default , ) )","title":"Developer Guide"},{"location":"guide/#developer-guide","text":"","title":"Developer Guide"},{"location":"guide/#synchronous-client-http-requests","text":"","title":"Synchronous Client - HTTP requests"},{"location":"guide/#initialization","text":"To initialize the client: examples/stxclient/init.py from stxsdk import StxClient client = StxClient ()","title":"Initialization"},{"location":"guide/#authentication","text":"Before performing any operation you must authenticate first, if the provided credentials are correct the login API will store the tokens automatically to be used for authenticated APIs otherwise it will return authentication failure response. examples/stxclient/login.py from stxsdk import StxClient client = StxClient () email = \"<email address>\" password = \"<password>\" result = client . login ( params = { \"email\" : email , \"password\" : password }, ) The user token and refresh token validity is automatically handled by the client internally, and you don\"t need to worry about handling the authentication and authorization. For understanding the token expiry is 1 hour and refresh token expiry is 24 hours.","title":"Authentication"},{"location":"guide/#2-factor-authentication","text":"If the 2FA is enabled, you must execute the confirm2fa to authenticate the user before calling any other operation, otherwise you will get the authentication failure response. examples/stxclient/confirm2FA.py from stxsdk import StxClient client = StxClient () email = \"<email address>\" password = \"<password>\" client . login ( params = { \"email\" : email , \"password\" : password }, ) # After login, if 2FA is enabled, you will receive the code on the requested email address client . confirm2Fa ( params = { \"code\" : \"865347\" , } )","title":"2 Factor Authentication"},{"location":"guide/#user-profile","text":"To get the user profile details examples/stxclient/user_profile.py from stxsdk import StxClient , Selection client = StxClient () email = \"<email address>\" password = \"<password>\" client . login ( params = { \"email\" : email , \"password\" : password }, ) selections = Selection ( \"accountId\" , \"city\" , \"country\" , \"firstName\" , \"lastName\" , \"username\" , \"id\" , ) result = client . userProfile ( selections = selections ) Response { \"data\" : { \"userProfile\" : { \"accountId\" : \"6a7fb2e7-1413-4b8b-b126-6a8eaab128a8\" , \"city\" : \"New York\" , \"country\" : No ne , \"firstName\" : \"Muhamad\" , \"id\" : \"d9988022-037e-4441-8132-69d1bc58343f\" , \"lastName\" : \"Ali\" , \"username\" : \"Ali.Muhamad.86702\" }}, \"errors\" : No ne , \"message\" : \"Request Processed Successfully\" , \"success\" : True , }","title":"User Profile"},{"location":"guide/#utilities","text":"Here you can see a Selection object is being created to pass as an argument selections to the userProfile function. If you doesn't pass the selections, you will get all the fields in return by default. Selections parameter is used to pass the fields that you want in return from the APIs. Now the question is how would you know which fields are available in the response of the API. We have a utility method get_return_fields that takes the name of the operation as a string and returns all the available response values with their names and types. To get the return fields from stxsdk import StxClient client = StxClient () result = client . get_return_fields ( \"userProfile\" ) Response { \"accountId\" : \"rID\" , \"address1\" : \"String\" , \"address2\" : \"String\" , \"city\" : \"String\" , \"country\" : \"String\" , \"dateOfBirth\" : \"String\" , \"firstName\" : \"String!\" , \"id\" : \"rID!\" , \"industry\" : \"String\" , \"jobTitle\" : \"String\" , \"lastName\" : \"String!\" , \"optInMarketing\" : \"Boolean\" , \"phoneNumber\" : \"String\" , \"ssn\" : \"String\" , \"state\" : \"String\" , \"twoFactorAuth\" : \"Boolean\" , \"twoFactorAuthPerDevice\" : \"Boolean\" , \"username\" : \"String!\" , \"zipCode\" : \"String\" } Now what about the response with nested fields, checkout the following example: To get the return values with nested fields from stxsdk import StxClient client = StxClient () result = client . get_return_fields ( \"marketInfos\" ) Response { \"archived\" : \"Boolean\" , \"closedAt\" : \"String\" , \"description\" : \"String\" , \"detailedEventBrief\" : \"String\" , \"homeCategory\" : \"String\" , \"eventId\" : \"rID\" , \"eventStart\" : \"String\" , \"eventStatus\" : \"String\" , \"title\" : \"String\" , \"eventType\" : \"String\" , \"eventBrief\" : \"String\" , \"lastProbabilityAt\" : \"DateTime\" , \"lastTradedPrice\" : \"Int\" , \"manualProbability\" : \"Boolean\" , \"marketId\" : \"rID\" , \"maxPrice\" : \"Int\" , \"position\" : \"String\" , \"price\" : \"Float\" , \"priceChange24h\" : \"Int\" , \"probability\" : \"Float\" , \"question\" : \"String\" , \"result\" : \"String\" , \"shortTitle\" : \"String\" , \"rulesSpecifier\" : \"String\" , \"specifier\" : \"String\" , \"status\" : \"String\" , \"timestamp\" : \"String\" , \"timestampInt\" : \"Int\" , \"volume24h\" : \"Int\" , \"symbol\" : \"String\" , \"tradingFilters\" : { \"category\" : \"String\" , \"manual\" : \"Boolean\" , \"section\" : \"String\" , \"subcategory\" : \"String\" }, \"recentTrades\" : { \"liquidityTaker\" : \"String\" , \"price\" : \"Int\" , \"quantity\" : \"Int\" , \"timestamp\" : \"String\" , \"timestampInt\" : \"Int\" }, \"offers\" : { \"price\" : \"Int\" , \"quantity\" : \"Int\" }, \"orderPriceRules\" : { \"from\" : \"Int\" , \"inc\" : \"Int\" , \"to\" : \"Int\" }, \"filters\" : { \"category\" : \"String\" , \"manual\" : \"Boolean\" , \"section\" : \"String\" , \"subcategory\" : \"String\" }, \"bids\" : { \"price\" : \"Int\" , \"quantity\" : \"Int\" } } You will get two types of responses in return from any operation Success Response { # API respo nse , i t could be lis t or dic t io nar y \"data\" : {}, # i t would always be No ne i n case o f success \"errors\" : No ne , # Success Message \"message\" : \"Request Processed Successfully\" , # A boolea n f ield , would always be True i n case o f success respo nse \"success\" : True , } Failure Response { # i t would be No ne i n case o f fa ilure \"data\" : No ne , # i t would a lis t o f errors \"errors\" : [], # Ge neral fa ilure message \"message\" : \"Failed to process the request\" , # A boolea n f ield , would always be False i n case o f success respo nse \"success\" : False , } You can also use the following function to get the list of available operations To get the list of avaiable operations from stxsdk import StxClient client = StxClient () result = client . get_operations ()","title":"Utilities"},{"location":"guide/#market-infos","text":"In the following example code you can see the usage of Selection object to set nested values examples/stxclient/market_info.py from stxsdk import StxClient , Selection client = StxClient () email = \"<email address>\" password = \"<password>\" client . login ( params = { \"email\" : email , \"password\" : password }, ) # you can create separate selection object and set them as keyword argument # or can create them inline # here created selection object for the field orderPriceRules and # pass it as keyword argument order_price_rules = Selection ( \"from\" , \"inc\" , \"to\" ) selections = Selection ( \"closedAt\" , \"description\" , \"eventId\" , \"marketId\" , \"title\" , \"status\" , orderPriceRules = order_price_rules , # inline selection object bids = Selection ( \"price\" , \"quantity\" ), ) result = client . marketInfos ( selections = selections )","title":"Market Infos"},{"location":"guide/#confirm-order","text":"examples/stxclient/confirm_order.py from stxsdk import StxClient , Selection client = StxClient () email = \"<email address>\" password = \"<password>\" client . login ( params = { \"email\" : email , \"password\" : password }, ) params = { \"userOrder\" : { \"marketId\" : \"ec202f18-cc6c-4fa2-90cb-f0c9162afced\" , # orderType: LIMIT | MARKET \"orderType\" : \"LIMIT\" , # action: BUY | SELL \"action\" : \"BUY\" , \"price\" : 1 , \"quantity\" : 5 , } } selections = Selection ( \"errors\" , order = Selection ( \"id\" , \"totalValue\" , \"status\" , \"action\" , \"clientOrderId\" ) ) result = client . confirmOrder ( params = params , selections = selections )","title":"Confirm Order"},{"location":"guide/#cancel-order","text":"examples/stxclient/cancel_order.py from stxsdk import StxClient , Selection client = StxClient () email = \"<email address>\" password = \"<password>\" client . login ( params = { \"email\" : email , \"password\" : password }, ) params = { \"orderId\" : \"85b670f1-19b7-4378-8b91-6b4d7cc4a46b\" } selections = Selection ( \"status\" ) result = client . cancelOrder ( params = params , selections = selections )","title":"Cancel Order"},{"location":"guide/#trade-history","text":"examples/stxclient/trade_history.py from stxsdk import StxClient , Selection client = StxClient () email = \"<email address>\" password = \"<password>\" client . login ( params = { \"email\" : email , \"password\" : password }, ) selections = Selection ( \"totalCount\" , orders = Selection ( \"id\" , \"orderType\" , \"price\" , \"quantity\" , \"clientOrderId\" , \"totalValue\" , \"marketId\" , \"status\" , ), ) result = client . myOrderHistory ( selections = selections )","title":"Trade History"},{"location":"guide/#asynchronous-client-websocket-requests","text":"This service provides the functionality to connect with the Sportsx phoenix channel via websockets.","title":"Asynchronous Client - Websocket requests"},{"location":"guide/#available-channels","text":"Channel Description portfolio_join It delivers updates to users' available balance market_info_join It gives information about active markets active_trades_join It delivers information to the subscriber on a trade executed against an order that is filled against an active market in the system active_orders_join It delivers information to the subscriber on order that are filled against an active market in the system active_settlements_join It delivers information to the subscriber on a settlement recorded against on an account for an active market in the system. active_positions_join It delivers information to the subscriber on a position an account holds in an active market","title":"Available Channels"},{"location":"guide/#initialization_1","text":"To initialize the client: examples/stxchannelclient/init.py email = \"<email address>\" password = \"<password>\" channel_client = StxChannelClient () channel_client . login ( params = { \"email\" : email , \"password\" : password }) channel_client = StxChannelClient () Note First of all, needs to know that the User management is built on singleton approach, It means that no matter how many StxClient or StxChannelClient objects you create all of them will be sharing the same user object. It is required to have authentication before initiating the async client for building the connection with the channels. In the following example you can see I used asyncio library for async communication with channels asyncio is Python's builtin library to write concurrent code using the async/await syntax. You can learn more about asyncio on its official documentation What is Consumer? It's a function or service that would be triggered by the async client, means that the channels' message will automatically hand off to a message listener which passes to the consumer that has been registered. The client consumes the message when a session thread invokes the onMessage() method of the message listener object. Our ChannelClient accepts different consumers for each event. The available events are the following: Event Description on_open It triggers when connected with the server on_message It triggers when connection to the server is closed on_close It triggers when connection to the server is closed on_error It triggers when any error send by the server or exception occurs default all of the above events are optional to be set, if you want a generic method to be run as default you can pass as it with default kwarg","title":"Initialization"},{"location":"guide/#response-syntax","text":"Success Message { \"closed\" : False , \"message_received\" : True , \"message\" : \"Message received\" , # i t would a lis t co nta i n i n g message o f t he cha nnel \"data\" : [], } Below is the sample data of the portfolio channel Sample Message Response of the Channel [ \"3\" , No ne , \"portfolio:EY8Zk0HKYbaMsiG8id81MTE0V1D3\" , \"summary\" , { \"account_balance\" : 2000000 , \"account_id\" : \"6a7fb2e7-1413-4b8b-b126-6a8eaab128a8\" , \"available_balance\" : 2000000 , \"buy_order_liability\" : 0 , \"escrow\" : 0 , \"position_premium_liability\" : 0 , \"sell_order_liability\" : 0 , \"total_deposits\" : 2000000 , \"total_fees\" : 0 , \"total_settlement_pnl\" : 0 , \"total_withdrawals\" : 0 , \"user_id\" : \"ca84fb65-5df2-456b-80ec-903a068bbdd2\" } ]","title":"Response Syntax"},{"location":"guide/#portfolio-channel","text":"examples/stxchannelclient/portfolio.py import asyncio from examples.stxchannelclient.init import channel_client async def on_open ( response ): # message passed by the listener of the async client when connect with the server # you can perform any initial operation on this event print ( f \"Successfully connected with the server with message, { response } \" ) async def on_message ( response ): # message passed by the listener of the async client when server send the message # you can perform any post operation on this event print ( response [ \"data\" ]) async def default ( response ): # Here response would be the response passed by the listener of the async client if response [ \"closed\" ]: print ( response [ \"message\" ]) elif response [ \"data\" ] is None : print ( \"No data return from server.\" ) else : print ( response [ \"data\" ][ 4 ]) # StxChannelClient provides the channel function as an asynchronous tasks, in order to execute # them async in a continuous loop using the asyncio module's event loop, # asynio is Python's built-in package that provides a foundation and API for running and managing coroutines. # here you can see that am only passing functions for on_open and on_message events # with a default function to handle other events asyncio . run ( channel_client . portfolio_join ( on_open = on_open , on_message = on_message , default = default , ) )","title":"Portfolio Channel"},{"location":"guide/#market-info-channel","text":"examples/stxchannelclient/market_info.py import asyncio from examples.stxchannelclient.init import channel_client async def on_open ( response ): # message passed by the listener of the async client when connect with the server # you can perform any initial operation on this event print ( f \"Successfully connected with the server with message, { response } \" ) async def on_message ( response ): # message passed by the listener of the async client when server send the message # you can perform any post operation on this event print ( response [ \"data\" ]) async def default ( response ): # Here response would be the response passed by the listener of the async client if response [ \"closed\" ]: print ( response [ \"message\" ]) elif response [ \"data\" ] is None : print ( \"No data return from server.\" ) else : print ( response [ \"data\" ][ 4 ]) # StxChannelClient provides the channel function as an asynchronous tasks, in order to execute # them async in a continuous loop using the asyncio module's event loop, # asynio is Python's built-in package that provides a foundation and API for running and managing coroutines. # here you can see that am only passing functions for on_open and on_message events # with a default function to handle other events asyncio . run ( channel_client . market_info_join ( on_open = on_open , on_message = on_message , default = default , ) )","title":"Market Info Channel"},{"location":"guide/#active-trades-channel","text":"examples/stxchannelclient/active_trade.py import asyncio from examples.stxchannelclient.init import channel_client async def on_open ( response ): # message passed by the listener of the async client when connect with the server # you can perform any initial operation on this event print ( f \"Successfully connected with the server with message, { response } \" ) async def on_message ( response ): # message passed by the listener of the async client when server send the message # you can perform any post operation on this event print ( response [ \"data\" ]) async def default ( response ): # Here response would be the response passed by the listener of the async client if response [ \"closed\" ]: print ( response [ \"message\" ]) elif response [ \"data\" ] is None : print ( \"No data return from server.\" ) else : print ( response [ \"data\" ][ 4 ]) # StxChannelClient provides the channel function as an asynchronous tasks, in order to execute # them async in a continuous loop using the asyncio module's event loop, # asynio is Python's built-in package that provides a foundation and API for running and managing coroutines. # here you can see that am only passing functions for on_open and on_message events # with a default function to handle other events asyncio . run ( channel_client . active_trades_join ( on_open = on_open , on_message = on_message , default = default , ) )","title":"Active Trades Channel"},{"location":"guide/#active-orders-channel","text":"examples/stxchannelclient/active_order.py import asyncio from examples.stxchannelclient.init import channel_client async def on_open ( response ): # message passed by the listener of the async client when connect with the server # you can perform any initial operation on this event print ( f \"Successfully connected with the server with message, { response } \" ) async def on_message ( response ): # message passed by the listener of the async client when server send the message # you can perform any post operation on this event print ( response [ \"data\" ]) async def default ( response ): # Here response would be the response passed by the listener of the async client if response [ \"closed\" ]: print ( response [ \"message\" ]) elif response [ \"data\" ] is None : print ( \"No data return from server.\" ) else : print ( response [ \"data\" ][ 4 ]) # StxChannelClient provides the channel function as an asynchronous tasks, in order to execute # them async in a continuous loop using the asyncio module's event loop, # asynio is Python's built-in package that provides a foundation and API for running and managing coroutines. # here you can see that am only passing functions for on_open and on_message events # with a default function to handle other events asyncio . run ( channel_client . active_orders_join ( on_open = on_open , on_message = on_message , default = default , ) )","title":"Active Orders Channel"},{"location":"guide/#active-settlement-channel","text":"examples/stxchannelclient/active_settlements.py import asyncio from examples.stxchannelclient.init import channel_client async def on_open ( response ): # message passed by the listener of the async client when connect with the server # you can perform any initial operation on this event print ( f \"Successfully connected with the server with message, { response } \" ) async def on_message ( response ): # message passed by the listener of the async client when server send the message # you can perform any post operation on this event print ( response [ \"data\" ]) async def default ( response ): # Here response would be the response passed by the listener of the async client if response [ \"closed\" ]: print ( response [ \"message\" ]) elif response [ \"data\" ] is None : print ( \"No data return from server.\" ) else : print ( response [ \"data\" ][ 4 ]) # StxChannelClient provides the channel function as an asynchronous tasks, in order to execute # them async in a continuous loop using the asyncio module's event loop, # asynio is Python's built-in package that provides a foundation and API for running and managing coroutines. # here you can see that am only passing functions for on_open and on_message events # with a default function to handle other events asyncio . run ( channel_client . active_settlements_join ( on_open = on_open , on_message = on_message , default = default , ) )","title":"Active Settlement Channel"},{"location":"guide/#active-positions-channel","text":"examples/stxchannelclient/active_positions.py import asyncio from examples.stxchannelclient.init import channel_client async def on_open ( response ): # message passed by the listener of the async client when connect with the server # you can perform any initial operation on this event print ( f \"Successfully connected with the server with message, { response } \" ) async def on_message ( response ): # message passed by the listener of the async client when server send the message # you can perform any post operation on this event print ( response [ \"data\" ]) async def default ( response ): # Here response would be the response passed by the listener of the async client if response [ \"closed\" ]: print ( response [ \"message\" ]) elif response [ \"data\" ] is None : print ( \"No data return from server.\" ) else : print ( response [ \"data\" ][ 4 ]) # StxChannelClient provides the channel function as an asynchronous tasks, in order to execute # them async in a continuous loop using the asyncio module's event loop, # asynio is Python's built-in package that provides a foundation and API for running and managing coroutines. # here you can see that am only passing functions for on_open and on_message events # with a default function to handle other events asyncio . run ( channel_client . active_positions_join ( on_open = on_open , on_message = on_message , default = default , ) )","title":"Active Positions Channel"},{"location":"quickstart/","text":"Quick Start \u00b6 The SDK is composed of two key sections: Proxy (the classes providing the low-level functionality) Client (the services to be used for connectivity with the STX APIs). All you need to use is Client services for the integration with the APIs. There are two services available StxClient and StxChannelClient StxClient provides sync operations, while StxChannelClient provides connectivity with websocket channels. StxClient \u00b6 It provides the following operations: login confirm2Fa send2Fa logout updateProfile updateUserProfile confirmOrder cancelOrder cancelOrders cancelAllOrders userProfile marketFilterTree marketInfos marketSettlements accountMarketStats accountLimitsNumber accountLimitsHistoryNumber myDepositAndWithdrawalHistory myOrderHistory mySettlementsHistory myTradesForOrder myTradesHistory tradesForSettlement StxChannelClient \u00b6 It provides the following websocket APIs: portfolio_join market_info_join active_trades_join active_orders_join active_settlements_join active_positions_join","title":"Quick Start"},{"location":"quickstart/#quick-start","text":"The SDK is composed of two key sections: Proxy (the classes providing the low-level functionality) Client (the services to be used for connectivity with the STX APIs). All you need to use is Client services for the integration with the APIs. There are two services available StxClient and StxChannelClient StxClient provides sync operations, while StxChannelClient provides connectivity with websocket channels.","title":"Quick Start"},{"location":"quickstart/#stxclient","text":"It provides the following operations: login confirm2Fa send2Fa logout updateProfile updateUserProfile confirmOrder cancelOrder cancelOrders cancelAllOrders userProfile marketFilterTree marketInfos marketSettlements accountMarketStats accountLimitsNumber accountLimitsHistoryNumber myDepositAndWithdrawalHistory myOrderHistory mySettlementsHistory myTradesForOrder myTradesHistory tradesForSettlement","title":"StxClient"},{"location":"quickstart/#stxchannelclient","text":"It provides the following websocket APIs: portfolio_join market_info_join active_trades_join active_orders_join active_settlements_join active_positions_join","title":"StxChannelClient"},{"location":"trading_bot/","text":"Trading Bot \u00b6 This document will guide you on the usage of SportsX SDK with an example to create a Trading Bot. Let's just set some requirements of the bot, what is the target of this bot what features this bot would have etc. The objective of this bot is to perform the following routine: - Get all the available markets from the API. - Pick a random market. - Extract the probability of the selected market. - Generate a random probability cap between 0 and 10 to add into the market current probability. probability = current_probability + (current_probability * random.choice(range(11)) / 100) - Generate the price using the generated probability and market's current max price. price = max market price * probability - Pick random quantity between 1 and 10 quantity = random.choice(range(11)) - Place an order with market id, price and quantity. - Initiate market channel and check if price shifts 5% either up down for that market. - Cancel the created order. - Post new order with new price. Before the implementation we are going to need the SDK. Installation \u00b6 Install the latest release via pip: pip install stx-pysdk The SDK is built for python 3 only. If your system has both python2 and python3 manager installed then by default \"pip\" refers to python2 manager, so in order to install for python3 \"pip3\" would be used pip3 install stx-pysdk Implementation \u00b6 We will start with the creating a project with name trading_bot . And create a python file with name bot.py in which we are creating a class TradingBot . This class will contain all the operations of the bot. trading_bot/bot.py class TradingBot : pass Now let's create a method called initiate that will be called to initiate the bot, this method will be responsible for calling the required operations as defined in the requirements. Before doing any operation it is required to have a valid authentication so the first step would be performing the authentication. We'll add an auth method __authenticate that will be called here to perform the authentication. After the auth the next step is to get the available markets, so we'll add a method __populate_markets that will be responsible for storing the market data to the bot object. Next step would be picking up the random market from previously stored markets data. After selecting the market we'll perform some computation based on our requirements and algorithms. __compute_price to compute the price at which we'll be placing the order. __get_quantity to get the quantity of the shares to be purchased. class TradingBot : def initiate ( self ): # Starts the bot by preforming the authentication for the APIs. self . __authenticate () # Populates the available markets using the market API. self . __populate_markets () # Randomly pick a market to which the order will be placed self . __pick_random_market () # compute the price on which the order will be placed price = self . __compute_price () # get the quantity of the shares for the order quantity = self . __get_quantity () For the authentication of the bot we need username and password, lets just update the authentication method to accept username and password as parameters to perform the authentication now the function would be. class TradingBot : def initiate ( self ): # Starts the bot by preforming the authentication for the APIs. self . __authenticate ( username , password ) ... Now its time to define these methods. We'll now use the provided StxClient by importing it from the installed SDK. from stxsdk import StxClient CLIENT = StxClient () Now that we have the client object, we'll be using it to interact with the SportsX APIs. So the authentication method would be: class TradingBot : @staticmethod def __authenticate ( email , password ): \"\"\" This function is authenticating the client with the provided credentials, and will raise the exception if authentication fails \"\"\" print ( \"Executing bot user authentication.\" ) # using StxClient object to initiate the login login_response = CLIENT . login ( params = { \"email\" : email , \"password\" : password }) # if the provided credentials are not correct it would get success False flag in response # with relative error message if not login_response [ \"success\" ]: logger . error ( f \"Failed to authenticate with the response: { login_response } \" ) raise AuthenticationFailedException ( login_response [ \"message\" ]) This is only a sample code for the authentication API usage, you can perform your own operations in case of success and failures. Market population method would be like: class TradingBot : def __populate_markets ( self ): \"\"\" This function is populating the bot markets by executing the marketInfos API \"\"\" print ( \"Initiating to populate the market data\" ) # making selection object of the required response fields # You can have your own list of selections as per your requirements # To learn more about what Selection is you can check out the guide section. selections = Selection ( \"title\" , \"shortTitle\" , \"marketId\" , \"eventType\" , \"status\" , \"maxPrice\" , \"probability\" , \"question\" , \"eventStatus\" , \"position\" , \"price\" , bids = Selection ( \"price\" , \"quantity\" ), offers = Selection ( \"price\" , \"quantity\" ), ) # executing the marketinfos API with the generated selection object print ( \"Executing the marketinfos API.\" ) market_data = CLIENT . marketInfos ( selections = selections ) if not market_data [ \"success\" ]: # if for any reason market info API fails, raise the exception msg = f \"Failed to get markets with error: { market_data [ 'errors' ] } \" logger . error ( msg ) raise MarketsNotFoundException ( msg ) else : self . markets . clear () market_data = market_data [ \"data\" ][ \"marketInfos\" ] print ( f \"Received { len ( market_data ) } markets.\" ) # storing the markets in the bot object to be randomly picked from # am making marketId to market data map for quick accessing the market # you can define your own data structure or store in database # depending on your use case, you can also filter out the markets based # on your preferences and requirements self . markets = { market [ \"marketId\" ]: market for market in market_data } This is sample code for populating the markets, you can define your own operation for markets extractions, and different approaches for handling success and failure cases. Here we are storing markets in the object, you can use any database to store them as per your requirements. Next step is to define the market picking method: class TradingBot : def __pick_random_market ( self ): \"\"\" This function is randomly picking a market from the available markets \"\"\" print ( \"Picking random market with the bids.\" ) # infinitely looping to pick the random market with bids available while True : # random.choice picks any element from the list in uniformly distributed manner market = random . choice ( list ( self . markets . values ())) # set the picked market to bot object for order creation # only if the market has bids available, and probability greater than 0 # you can set any other conditions based on your requirements if market . get ( \"bids\" ) and market . get ( \"probability\" ) > 0 : self . market = market print ( f \"The picked market is { market [ 'shortTitle' ] } , having id { market [ 'marketId' ] } \" ) # breaks the loop when the market is picked break This is sample code for picking up the market on which we'll be placing order, you can have your own algorithm for picking the right market to place order on. Once you picked the market now lets define the methods that will be calculating the parameters for placing the order. Order required 5 parameters, marktetId , orderType , action , quantity and price . We can get the marketId from the picked market object. For this example we'll be using LIMIT as orderType , you can have your own logic for deciding the order type, available order types are LIMIT and MARKET Setting action as BUY because this bot will be buying the shares, you can have your own logic to decide the action based on you requirements. For quantity , as per our requirement we will be randomly choosing the value between 1 and 10, you can have your own logic to decide the quantity of the shares. class TradingBot : @staticmethod def __get_quantity (): # returns random quantity between 1 and 10 return random . choice ( range ( 1 , 11 )) For price we have a defined formula that will be using to compute the price to place the order on. You can have your own algorithm, logic to compute the price. class TradingBot : def __extract_market_probability ( self ): \"\"\" This function is returning the probability of the selected market \"\"\" print ( \"Getting the market probability.\" ) # returns the market's probability return self . market [ \"probability\" ] def __compute_price ( self ): \"\"\" This function is computing the price using the market's current probability on which the order would be placed. \"\"\" # extract the current probability of the picked market probability = self . __extract_market_probability () print ( f \"Computing the price for order creation, market current probability is { probability } \" ) # get random probability cap between 0 and 10 to add into the market current probability probability_cap = random . choice ( range ( 11 )) # increasing the probability by the percent of the computed cap probability += probability * probability_cap / 100 print ( f \"Generated probability is { probability } \" ) # get the max price of all the bids max_market_price = max ( bid [ \"price\" ] for bid in self . market [ \"bids\" ]) # price = integer type (max market price * computed probability) # type casting to int, because following command will return as float # and the price should be integer type price = int ( max_market_price * probability ) print ( f \"Computed price is { price } \" ) return price Once we get the values of all the required parameters we'll move to place the order. Following is an example code for placing the order, you can have your own logic for placing the order and perform different operations on success and failure cases. class TradingBot : def __create_order ( self , market_id , quantity , price ): \"\"\" This function is posting a new order with the provided details :param market_id: unique ID of the market :param quantity: quantity of the shares to be purchased :param price: the price at which the shares would be purchased \"\"\" print ( f \"Initiating to create the order for market id: { market_id } , \" f \"with price: { price } and quantity: { quantity } .\" ) # generate the request params for order creation params = { \"userOrder\" : { \"marketId\" : market_id , \"orderType\" : \"LIMIT\" , \"action\" : \"BUY\" , \"quantity\" : quantity , \"price\" : price , } } # request the confirmOrder API to post the order order_response = CLIENT . confirmOrder ( params = params ) # if the response is not successful raise the exception if not order_response [ \"success\" ]: msg = f \"Order creating failed with error { order_response [ 'message' ] } \" logger . error ( msg ) raise OrderCreationFailure ( msg ) # if order created successfully then set the order data to the bot object order = order_response [ \"data\" ][ \"confirmOrder\" ][ 'order' ] order_total = order [ 'quantity' ] * order [ \"price\" ] print ( f \"Order is created with id: { order [ 'id' ] } and total price is { order_total } \" ) self . order = order As you can see am storing the placed order information in the object, you can store it in the database or something as per your requirements. Now that we have placed the order, our next target is to keep checkout the market's price change and whenever price shifts 5% up or down, cancel the order and place new one with different prices. We have to define a method to cancel the order. class TradingBot : def __cancel_order ( self ): \"\"\" This function is cancelling the order using cancelOrder API \"\"\" if not self . order : return print ( f \"Cancelling the order with id { self . order [ 'id' ] } \" ) # generate the request params for cancelling the order params = { \"orderId\" : self . order [ \"id\" ]} CLIENT . cancelOrder ( params = params ) # resetting the bot current order to None after cancelling the order self . order = None You can have your own logic of cancelling the order this is just an example usage on how you can cancel the order using SDK. Now the question is how we can track the market prices or any other updates to the market. We have another client class available in the SDK that allow us to connect with the SportsX channels (Websocket Channels). You can learn more about what channels are, what channels are available in the guide section. Here we will be using the market info channel, this channel asynchronously sends the updates to our passed consumers which then can be used to perform any required operations. In order to connect with the channel you have to create a StxChannelClient object by importing from the SDK. from stxsdk import StxChannelClient CHANNEL_CLIENT = StxChannelClient () Now this channel client will be used to connect with the SportsX market info channel. We have to define a method that will be initiating the connection with channel and pass our defined consumers. import asyncio class TradingBot : def initiate_market_info_channel ( self ): \"\"\" This function is initiating the market info channel to check for the price shifts here we are using asyncio for asynchronous communication with the server \"\"\" asyncio . run ( CHANNEL_CLIENT . market_info_join ( on_message = self . on_market_info_update , on_close = self . on_market_close , on_error = self . on_market_error , ) ) As you can see we are passing 3 methods, on_market_info_update , on_market_close and on_market_error . These are the consumer methods, you can learn more about consumers on the guide section. Quick introduction is that we can pass different consumer methods to each available events to be triggered on. Event Description on_open It triggers when connected with the server on_message It triggers when connection to the server is closed on_close It triggers when connection to the server is closed on_error It triggers when any error send by the server or exception occurs default all of the above events are optional to be set, if you want a generic method to be run as default you can pass as it with default kwarg We are using asyncio to connect with channels, you can use any other asynchronous libraries to connect with the channels. Following is the sample code of the consumer methods, you can have your own logic to be performed based on the requirements class TradingBot : async def on_market_info_update ( self , response ): \"\"\" This function will be called whenever there is an update to a market. It checks if the update is happened to the market which we placed order for If market id matches, checkout for the price shift, if the shift is 5% up or down. Cancel the order and post new order with new price. Sample channel response: { 'closed': False, 'message_received': True, 'message': 'Message received', 'data': [ None, None, 'market_info', 'market_updated', { 'd76112d8-2537-4c20-a376-37c74fbe7977': { 'market_id': 'd76112d8-2537-4c20-a376-37c74fbe7977', 'offers': [ {'price': 5400, 'quantity': 10}, {'price': 3500, 'quantity': 8}, {'price': 3400, 'quantity': 66}, ], 'price': 3150.0, 'timestamp': '2023-01-17T16:53:26.324012Z', 'unix_timestamp': 1673974406324012, } } ] } the data key contains the server response data is a list, where 3rd element is the message event for example when market gets updated it will be 'market_updated', when new market created it will be 'market_created' the 4th element is the market data, this market data will have mandatory 'market_id' and 'timestamp' fields indicating what market change and when with only the changed fields \"\"\" try : data = response [ \"data\" ] market_response_type = data [ 3 ] market_response_data = data [ 4 ] # suppressing the StopIteration exception to pass the empty response data with contextlib . suppress ( StopIteration ): # getting the market data from the response, response is a dictionary # using next with iter to get the first element of the response dict # next raises StopIteration exception if empty iter is provided # the above context is suppressing this case market_data = market_response_data [ next ( iter ( market_response_data ))] # checking if the server message is for market update # also if the update happened for the market we placed order on if ( market_response_type == \"market_updated\" and market_data [ \"market_id\" ] == self . market [ \"marketId\" ] ): print ( \"The market has been updated.\" ) # market data will only have those fields that are updated market_latest_price = market_data . get ( \"price\" ) # if the market data has price field, it means the market price is shifted if market_latest_price : order_price = self . order [ \"price\" ] print ( f \"The market price is changed, old price: { order_price } , new price: { market_latest_price } \" ) # get the 5% max and min price cap of the order's price max_shift = order_price + ( order_price * 5 / 100 ) min_shift = order_price - ( order_price * 5 / 100 ) # checking if the latest price is between the price shift cap if max_shift > market_latest_price < min_shift : print ( \"A price shift of 5 % u p/down is detected. Cancelling the order.\" ) # cancel the order and post the new order with new price for the same market self . __cancel_order () quantity = self . __get_quantity () print ( \"Posting the new order with the latest market price.\" ) self . __create_order ( self . market [ \"marketId\" ], quantity , market_latest_price ) except Exception as exc : # if any general exception occurs, cancel the order if any posted print ( f \"The bot operation failed with exception: { exc } \" ) if self . order : self . __cancel_order () async def on_market_close ( self , response = None ): print ( f \"Market channel has been closed with response: { response } \" ) print ( \"Cancelling the order.\" ) self . __cancel_order () async def on_market_error ( self , response = None ): print ( f \"Faced an exception or error with response: { response } \" ) print ( \"Cancelling the order.\" ) self . __cancel_order () After including the order creation and market channel connection methods the bot initiate method could use them as following: class TradingBot : def initiate ( self , email , password ): \"\"\" This function is step by step performing the defined routines \"\"\" # Starts the bot by preforming the authentication for the APIs. self . __authenticate ( email , password ) # Populates the available markets using the market API. self . __populate_markets () # Randomly pick a market to which the order will be placed self . __pick_random_market () # compute the price on which the order will be placed price = self . __compute_price () # get the quantity of the shares for the order quantity = self . __get_quantity () # Post the order with the generated quantity and price try : self . __create_order ( self . market [ \"marketId\" ], quantity , price ) # connecting with the market info channel to look out for the price shift self . initiate_market_info_channel () except Exception as exc : # if any general exception occurs, cancel the order if any posted print ( f \"The bot operation failed with exception: { exc } \" ) if self . order : self . __cancel_order () you can check out the whole sample code of Trading Bot on the trading_bot package","title":"Trading Bot Example"},{"location":"trading_bot/#trading-bot","text":"This document will guide you on the usage of SportsX SDK with an example to create a Trading Bot. Let's just set some requirements of the bot, what is the target of this bot what features this bot would have etc. The objective of this bot is to perform the following routine: - Get all the available markets from the API. - Pick a random market. - Extract the probability of the selected market. - Generate a random probability cap between 0 and 10 to add into the market current probability. probability = current_probability + (current_probability * random.choice(range(11)) / 100) - Generate the price using the generated probability and market's current max price. price = max market price * probability - Pick random quantity between 1 and 10 quantity = random.choice(range(11)) - Place an order with market id, price and quantity. - Initiate market channel and check if price shifts 5% either up down for that market. - Cancel the created order. - Post new order with new price. Before the implementation we are going to need the SDK.","title":"Trading Bot"},{"location":"trading_bot/#installation","text":"Install the latest release via pip: pip install stx-pysdk The SDK is built for python 3 only. If your system has both python2 and python3 manager installed then by default \"pip\" refers to python2 manager, so in order to install for python3 \"pip3\" would be used pip3 install stx-pysdk","title":"Installation"},{"location":"trading_bot/#implementation","text":"We will start with the creating a project with name trading_bot . And create a python file with name bot.py in which we are creating a class TradingBot . This class will contain all the operations of the bot. trading_bot/bot.py class TradingBot : pass Now let's create a method called initiate that will be called to initiate the bot, this method will be responsible for calling the required operations as defined in the requirements. Before doing any operation it is required to have a valid authentication so the first step would be performing the authentication. We'll add an auth method __authenticate that will be called here to perform the authentication. After the auth the next step is to get the available markets, so we'll add a method __populate_markets that will be responsible for storing the market data to the bot object. Next step would be picking up the random market from previously stored markets data. After selecting the market we'll perform some computation based on our requirements and algorithms. __compute_price to compute the price at which we'll be placing the order. __get_quantity to get the quantity of the shares to be purchased. class TradingBot : def initiate ( self ): # Starts the bot by preforming the authentication for the APIs. self . __authenticate () # Populates the available markets using the market API. self . __populate_markets () # Randomly pick a market to which the order will be placed self . __pick_random_market () # compute the price on which the order will be placed price = self . __compute_price () # get the quantity of the shares for the order quantity = self . __get_quantity () For the authentication of the bot we need username and password, lets just update the authentication method to accept username and password as parameters to perform the authentication now the function would be. class TradingBot : def initiate ( self ): # Starts the bot by preforming the authentication for the APIs. self . __authenticate ( username , password ) ... Now its time to define these methods. We'll now use the provided StxClient by importing it from the installed SDK. from stxsdk import StxClient CLIENT = StxClient () Now that we have the client object, we'll be using it to interact with the SportsX APIs. So the authentication method would be: class TradingBot : @staticmethod def __authenticate ( email , password ): \"\"\" This function is authenticating the client with the provided credentials, and will raise the exception if authentication fails \"\"\" print ( \"Executing bot user authentication.\" ) # using StxClient object to initiate the login login_response = CLIENT . login ( params = { \"email\" : email , \"password\" : password }) # if the provided credentials are not correct it would get success False flag in response # with relative error message if not login_response [ \"success\" ]: logger . error ( f \"Failed to authenticate with the response: { login_response } \" ) raise AuthenticationFailedException ( login_response [ \"message\" ]) This is only a sample code for the authentication API usage, you can perform your own operations in case of success and failures. Market population method would be like: class TradingBot : def __populate_markets ( self ): \"\"\" This function is populating the bot markets by executing the marketInfos API \"\"\" print ( \"Initiating to populate the market data\" ) # making selection object of the required response fields # You can have your own list of selections as per your requirements # To learn more about what Selection is you can check out the guide section. selections = Selection ( \"title\" , \"shortTitle\" , \"marketId\" , \"eventType\" , \"status\" , \"maxPrice\" , \"probability\" , \"question\" , \"eventStatus\" , \"position\" , \"price\" , bids = Selection ( \"price\" , \"quantity\" ), offers = Selection ( \"price\" , \"quantity\" ), ) # executing the marketinfos API with the generated selection object print ( \"Executing the marketinfos API.\" ) market_data = CLIENT . marketInfos ( selections = selections ) if not market_data [ \"success\" ]: # if for any reason market info API fails, raise the exception msg = f \"Failed to get markets with error: { market_data [ 'errors' ] } \" logger . error ( msg ) raise MarketsNotFoundException ( msg ) else : self . markets . clear () market_data = market_data [ \"data\" ][ \"marketInfos\" ] print ( f \"Received { len ( market_data ) } markets.\" ) # storing the markets in the bot object to be randomly picked from # am making marketId to market data map for quick accessing the market # you can define your own data structure or store in database # depending on your use case, you can also filter out the markets based # on your preferences and requirements self . markets = { market [ \"marketId\" ]: market for market in market_data } This is sample code for populating the markets, you can define your own operation for markets extractions, and different approaches for handling success and failure cases. Here we are storing markets in the object, you can use any database to store them as per your requirements. Next step is to define the market picking method: class TradingBot : def __pick_random_market ( self ): \"\"\" This function is randomly picking a market from the available markets \"\"\" print ( \"Picking random market with the bids.\" ) # infinitely looping to pick the random market with bids available while True : # random.choice picks any element from the list in uniformly distributed manner market = random . choice ( list ( self . markets . values ())) # set the picked market to bot object for order creation # only if the market has bids available, and probability greater than 0 # you can set any other conditions based on your requirements if market . get ( \"bids\" ) and market . get ( \"probability\" ) > 0 : self . market = market print ( f \"The picked market is { market [ 'shortTitle' ] } , having id { market [ 'marketId' ] } \" ) # breaks the loop when the market is picked break This is sample code for picking up the market on which we'll be placing order, you can have your own algorithm for picking the right market to place order on. Once you picked the market now lets define the methods that will be calculating the parameters for placing the order. Order required 5 parameters, marktetId , orderType , action , quantity and price . We can get the marketId from the picked market object. For this example we'll be using LIMIT as orderType , you can have your own logic for deciding the order type, available order types are LIMIT and MARKET Setting action as BUY because this bot will be buying the shares, you can have your own logic to decide the action based on you requirements. For quantity , as per our requirement we will be randomly choosing the value between 1 and 10, you can have your own logic to decide the quantity of the shares. class TradingBot : @staticmethod def __get_quantity (): # returns random quantity between 1 and 10 return random . choice ( range ( 1 , 11 )) For price we have a defined formula that will be using to compute the price to place the order on. You can have your own algorithm, logic to compute the price. class TradingBot : def __extract_market_probability ( self ): \"\"\" This function is returning the probability of the selected market \"\"\" print ( \"Getting the market probability.\" ) # returns the market's probability return self . market [ \"probability\" ] def __compute_price ( self ): \"\"\" This function is computing the price using the market's current probability on which the order would be placed. \"\"\" # extract the current probability of the picked market probability = self . __extract_market_probability () print ( f \"Computing the price for order creation, market current probability is { probability } \" ) # get random probability cap between 0 and 10 to add into the market current probability probability_cap = random . choice ( range ( 11 )) # increasing the probability by the percent of the computed cap probability += probability * probability_cap / 100 print ( f \"Generated probability is { probability } \" ) # get the max price of all the bids max_market_price = max ( bid [ \"price\" ] for bid in self . market [ \"bids\" ]) # price = integer type (max market price * computed probability) # type casting to int, because following command will return as float # and the price should be integer type price = int ( max_market_price * probability ) print ( f \"Computed price is { price } \" ) return price Once we get the values of all the required parameters we'll move to place the order. Following is an example code for placing the order, you can have your own logic for placing the order and perform different operations on success and failure cases. class TradingBot : def __create_order ( self , market_id , quantity , price ): \"\"\" This function is posting a new order with the provided details :param market_id: unique ID of the market :param quantity: quantity of the shares to be purchased :param price: the price at which the shares would be purchased \"\"\" print ( f \"Initiating to create the order for market id: { market_id } , \" f \"with price: { price } and quantity: { quantity } .\" ) # generate the request params for order creation params = { \"userOrder\" : { \"marketId\" : market_id , \"orderType\" : \"LIMIT\" , \"action\" : \"BUY\" , \"quantity\" : quantity , \"price\" : price , } } # request the confirmOrder API to post the order order_response = CLIENT . confirmOrder ( params = params ) # if the response is not successful raise the exception if not order_response [ \"success\" ]: msg = f \"Order creating failed with error { order_response [ 'message' ] } \" logger . error ( msg ) raise OrderCreationFailure ( msg ) # if order created successfully then set the order data to the bot object order = order_response [ \"data\" ][ \"confirmOrder\" ][ 'order' ] order_total = order [ 'quantity' ] * order [ \"price\" ] print ( f \"Order is created with id: { order [ 'id' ] } and total price is { order_total } \" ) self . order = order As you can see am storing the placed order information in the object, you can store it in the database or something as per your requirements. Now that we have placed the order, our next target is to keep checkout the market's price change and whenever price shifts 5% up or down, cancel the order and place new one with different prices. We have to define a method to cancel the order. class TradingBot : def __cancel_order ( self ): \"\"\" This function is cancelling the order using cancelOrder API \"\"\" if not self . order : return print ( f \"Cancelling the order with id { self . order [ 'id' ] } \" ) # generate the request params for cancelling the order params = { \"orderId\" : self . order [ \"id\" ]} CLIENT . cancelOrder ( params = params ) # resetting the bot current order to None after cancelling the order self . order = None You can have your own logic of cancelling the order this is just an example usage on how you can cancel the order using SDK. Now the question is how we can track the market prices or any other updates to the market. We have another client class available in the SDK that allow us to connect with the SportsX channels (Websocket Channels). You can learn more about what channels are, what channels are available in the guide section. Here we will be using the market info channel, this channel asynchronously sends the updates to our passed consumers which then can be used to perform any required operations. In order to connect with the channel you have to create a StxChannelClient object by importing from the SDK. from stxsdk import StxChannelClient CHANNEL_CLIENT = StxChannelClient () Now this channel client will be used to connect with the SportsX market info channel. We have to define a method that will be initiating the connection with channel and pass our defined consumers. import asyncio class TradingBot : def initiate_market_info_channel ( self ): \"\"\" This function is initiating the market info channel to check for the price shifts here we are using asyncio for asynchronous communication with the server \"\"\" asyncio . run ( CHANNEL_CLIENT . market_info_join ( on_message = self . on_market_info_update , on_close = self . on_market_close , on_error = self . on_market_error , ) ) As you can see we are passing 3 methods, on_market_info_update , on_market_close and on_market_error . These are the consumer methods, you can learn more about consumers on the guide section. Quick introduction is that we can pass different consumer methods to each available events to be triggered on. Event Description on_open It triggers when connected with the server on_message It triggers when connection to the server is closed on_close It triggers when connection to the server is closed on_error It triggers when any error send by the server or exception occurs default all of the above events are optional to be set, if you want a generic method to be run as default you can pass as it with default kwarg We are using asyncio to connect with channels, you can use any other asynchronous libraries to connect with the channels. Following is the sample code of the consumer methods, you can have your own logic to be performed based on the requirements class TradingBot : async def on_market_info_update ( self , response ): \"\"\" This function will be called whenever there is an update to a market. It checks if the update is happened to the market which we placed order for If market id matches, checkout for the price shift, if the shift is 5% up or down. Cancel the order and post new order with new price. Sample channel response: { 'closed': False, 'message_received': True, 'message': 'Message received', 'data': [ None, None, 'market_info', 'market_updated', { 'd76112d8-2537-4c20-a376-37c74fbe7977': { 'market_id': 'd76112d8-2537-4c20-a376-37c74fbe7977', 'offers': [ {'price': 5400, 'quantity': 10}, {'price': 3500, 'quantity': 8}, {'price': 3400, 'quantity': 66}, ], 'price': 3150.0, 'timestamp': '2023-01-17T16:53:26.324012Z', 'unix_timestamp': 1673974406324012, } } ] } the data key contains the server response data is a list, where 3rd element is the message event for example when market gets updated it will be 'market_updated', when new market created it will be 'market_created' the 4th element is the market data, this market data will have mandatory 'market_id' and 'timestamp' fields indicating what market change and when with only the changed fields \"\"\" try : data = response [ \"data\" ] market_response_type = data [ 3 ] market_response_data = data [ 4 ] # suppressing the StopIteration exception to pass the empty response data with contextlib . suppress ( StopIteration ): # getting the market data from the response, response is a dictionary # using next with iter to get the first element of the response dict # next raises StopIteration exception if empty iter is provided # the above context is suppressing this case market_data = market_response_data [ next ( iter ( market_response_data ))] # checking if the server message is for market update # also if the update happened for the market we placed order on if ( market_response_type == \"market_updated\" and market_data [ \"market_id\" ] == self . market [ \"marketId\" ] ): print ( \"The market has been updated.\" ) # market data will only have those fields that are updated market_latest_price = market_data . get ( \"price\" ) # if the market data has price field, it means the market price is shifted if market_latest_price : order_price = self . order [ \"price\" ] print ( f \"The market price is changed, old price: { order_price } , new price: { market_latest_price } \" ) # get the 5% max and min price cap of the order's price max_shift = order_price + ( order_price * 5 / 100 ) min_shift = order_price - ( order_price * 5 / 100 ) # checking if the latest price is between the price shift cap if max_shift > market_latest_price < min_shift : print ( \"A price shift of 5 % u p/down is detected. Cancelling the order.\" ) # cancel the order and post the new order with new price for the same market self . __cancel_order () quantity = self . __get_quantity () print ( \"Posting the new order with the latest market price.\" ) self . __create_order ( self . market [ \"marketId\" ], quantity , market_latest_price ) except Exception as exc : # if any general exception occurs, cancel the order if any posted print ( f \"The bot operation failed with exception: { exc } \" ) if self . order : self . __cancel_order () async def on_market_close ( self , response = None ): print ( f \"Market channel has been closed with response: { response } \" ) print ( \"Cancelling the order.\" ) self . __cancel_order () async def on_market_error ( self , response = None ): print ( f \"Faced an exception or error with response: { response } \" ) print ( \"Cancelling the order.\" ) self . __cancel_order () After including the order creation and market channel connection methods the bot initiate method could use them as following: class TradingBot : def initiate ( self , email , password ): \"\"\" This function is step by step performing the defined routines \"\"\" # Starts the bot by preforming the authentication for the APIs. self . __authenticate ( email , password ) # Populates the available markets using the market API. self . __populate_markets () # Randomly pick a market to which the order will be placed self . __pick_random_market () # compute the price on which the order will be placed price = self . __compute_price () # get the quantity of the shares for the order quantity = self . __get_quantity () # Post the order with the generated quantity and price try : self . __create_order ( self . market [ \"marketId\" ], quantity , price ) # connecting with the market info channel to look out for the price shift self . initiate_market_info_channel () except Exception as exc : # if any general exception occurs, cancel the order if any posted print ( f \"The bot operation failed with exception: { exc } \" ) if self . order : self . __cancel_order () you can check out the whole sample code of Trading Bot on the trading_bot package","title":"Implementation"}]}